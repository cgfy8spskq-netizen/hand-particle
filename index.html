<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>3D Particle - Hand Gesture (iPhone Optimized)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: Arial; touch-action: none; }
    #video { position: absolute; top: 10px; left: 10px; width: 200px; height: 150px; border: 2px solid #0f0; z-index: 10; opacity: 0.6; }
    #info { position: absolute; bottom: 10px; left: 10px; right: 10px; color: white; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; z-index: 10; font-size: 14px; text-align: center; }
    canvas { display: block; }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <div id="info">Trên iPhone: Cho phép camera → Đưa tay vào khung • Mở tay: mở rộng • Nắm tay: thu nhỏ + đổi màu • Chỉ trỏ: đổi kiểu • Giơ 2 ngón: xoay nhanh • Ngón cái: bùng nổ • Nghiêng tay: di chuyển</div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>

  <!-- Optional Bloom - chỉ bật nếu không lag -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>

  <script>
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ==================== Three.js Setup ====================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1f);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 80);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Giảm chất lượng trên mobile
    document.body.appendChild(renderer.domElement);

    // Bloom chỉ bật nếu không phải iOS (hoặc test)
    let composer = null;
    let bloomPass = null;
    if (!isIOS) {
      composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);
      bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.3, 0.6);
      bloomPass.threshold = 0.2;
      bloomPass.strength = 1.0;
      bloomPass.radius = 0.5;
      composer.addPass(bloomPass);
    }

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const pointLight = new THREE.PointLight(0xffffff, 1.2);
    scene.add(pointLight);

    // ==================== Particle ====================
    let particles, particleGeometry, particleMaterial;
    const particleCount = isIOS ? 5000 : 10000; // Giảm trên iOS
    let currentTemplate = 0;
    const templates = ['default', 'hearts', 'flowers', 'saturn', 'fireworks'];
    let velocities = [];
    let particleTargetPosition = new THREE.Vector3();

    function createParticles() {
      if (particles) scene.remove(particles);

      particleGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      velocities = [];

      for (let i = 0; i < particleCount; i++) {
        let x = (Math.random() - 0.5) * 60;
        let y = (Math.random() - 0.5) * 60;
        let z = (Math.random() - 0.5) * 60;

        // Giữ nguyên logic shape như cũ (hearts, flowers, etc.)
        if (currentTemplate === 1) { // hearts
          const angle = Math.random() * Math.PI * 2;
          x = 12 * Math.pow(Math.sin(angle), 3);
          y = 10 * Math.cos(angle) - 4 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle);
        } // ... (giữ nguyên các template khác)

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        const hue = i / particleCount + Math.random() * 0.1;
        colors[i * 3] = hue;
        colors[i * 3 + 1] = 0.9;
        colors[i * 3 + 2] = 0.7;
        sizes[i] = 1.2 + Math.random() * 2;

        velocities.push(new THREE.Vector3((Math.random() - 0.5)*0.03, (Math.random() - 0.5)*0.03, (Math.random() - 0.5)*0.03));
      }

      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
      particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      particleMaterial = new THREE.PointsMaterial({
        vertexColors: true,
        size: 1.0,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);
    }

    createParticles();

    let clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (particles) {
        particles.rotation.y += 0.001 * delta * 60;
        particles.rotation.x += 0.0005 * delta * 60;

        const positions = particleGeometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] += velocities[i].x * delta * 60;
          positions[i * 3 + 1] += velocities[i].y * delta * 60;
          positions[i * 3 + 2] += velocities[i].z * delta * 60;

          // Attract to target
          const dx = particleTargetPosition.x - positions[i * 3];
          velocities[i].x += dx * 0.00008 * delta * 60;
          // Tương tự cho y, z...

          // Bound
          if (Math.abs(positions[i * 3]) > 80) velocities[i].x *= -0.7;
        }
        particleGeometry.attributes.position.needsUpdate = true;
      }

      if (composer) composer.render();
      else renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) composer.setSize(window.innerWidth, window.innerHeight);
    });

    // ==================== MediaPipe ====================
    const videoElement = document.getElementById('video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`});

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 0,          // Giảm complexity cho iOS
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraFeed = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({image: videoElement});
      },
      width: isIOS ? 320 : 480,
      height: isIOS ? 240 : 360
    });
    cameraFeed.start().catch(err => {
      console.error("Camera error:", err);
      alert("Không truy cập được camera. Hãy thử HTTPS và cho phép camera trong Safari.");
    });

    let lastGestureTime = 0;
    function onResults(results) {
      if (!results.multiHandLandmarks) return;

      const hand = results.multiHandLandmarks[0];
      const now = Date.now();
      if (now - lastGestureTime < 400) return; // Debounce nhanh hơn

      const wrist = hand[0];
      const thumbTip = hand[4];
      const indexTip = hand[8];
      const middleTip = hand[12];
      const ringTip = hand[16];
      const pinkyTip = hand[20];

      // Cử chỉ (giữ nguyên nhưng điều chỉnh threshold nhẹ cho iOS)
      const isOpenPalm = thumbTip.y < wrist.y && indexTip.y < wrist.y && Math.abs(thumbTip.x - pinkyTip.x) > 0.08;
      const isFist = thumbTip.y > indexTip.y && indexTip.y > middleTip.y;
      const isIndexUp = indexTip.y < thumbTip.y && indexTip.y < middleTip.y && indexTip.y < ringTip.y;
      const isTwoFingers = indexTip.y < wrist.y && middleTip.y < wrist.y && ringTip.y > middleTip.y;
      const isThumbUp = thumbTip.y < wrist.y && indexTip.y > thumbTip.y && middleTip.y > thumbTip.y;

      const handTiltX = (wrist.x - 0.5) * 150;
      const handTiltY = (wrist.y - 0.5) * -150;

      if (isOpenPalm) {
        particleMaterial.size = THREE.MathUtils.lerp(particleMaterial.size, 2.8, 0.12);
        if (bloomPass) bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 1.4, 0.1);
      } else if (isFist) {
        particleMaterial.size = THREE.MathUtils.lerp(particleMaterial.size, 0.6, 0.15);
        const colors = particleGeometry.attributes.color.array;
        for (let i = 0; i < particleCount; i += 3) {
          colors[i] = Math.random();
          colors[i+1] = 0.8 + Math.random()*0.2;
          colors[i+2] = 0.6 + Math.random()*0.4;
        }
        particleGeometry.attributes.color.needsUpdate = true;
      } else if (isIndexUp) {
        currentTemplate = (currentTemplate + 1) % templates.length;
        createParticles();
      } else if (isTwoFingers) {
        // Xoay nhanh hơn
        particles.rotation.y += 0.05;
      } else if (isThumbUp) {
        currentTemplate = 4;
        createParticles();
        velocities.forEach(v => v.multiplyScalar(2));
      }

      particleTargetPosition.set(handTiltX, handTiltY, 0);

      lastGestureTime = now;
    }
  </script>
</body>
</html>

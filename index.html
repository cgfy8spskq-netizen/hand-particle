<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>3D Particle Hand Gesture - iPhone Fixed</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: Arial; touch-action: none; }
    #video { position: absolute; top: 10px; left: 10px; width: 180px; height: 240px; border: 2px solid #0f0; z-index: 10; opacity: 0.7; transform: scaleX(-1); } /* Mirror cho giống gương */
    #info { position: absolute; bottom: 20px; left: 10px; right: 10px; color: white; background: rgba(0,0,0,0.7); padding: 12px; border-radius: 10px; z-index: 10; font-size: 15px; text-align: center; }
    canvas { display: block; }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <div id="info">Trên iPhone: Cho phép camera → Đưa tay vào khung (ngược lại vì mirror) • Mở tay: mở rộng • Nắm tay: thu nhỏ + đổi màu • Chỉ trỏ: đổi kiểu particle • Giơ ngón cái: bùng nổ</div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>

  <!-- MediaPipe Tasks Vision (phiên bản mới, tốt cho iOS) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.js"></script>

  <script type="module">
    const { HandLandmarker, FilesetResolver, DrawingUtils } = window.vision;

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ==================== Three.js Setup ====================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1f);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 80);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    scene.add(new THREE.PointLight(0xffffff, 1.2));

    // ==================== Particle ====================
    let particles, geometry, material;
    const count = isIOS ? 4000 : 8000;
    let currentTemplate = 0;
    const templates = ['default', 'hearts', 'flowers', 'saturn', 'fireworks'];
    let velocities = [];
    let targetPos = new THREE.Vector3();

    function createParticles() {
      if (particles) scene.remove(particles);

      geometry = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const col = new Float32Array(count * 3);
      const size = new Float32Array(count);

      velocities = [];

      for (let i = 0; i < count; i++) {
        let x = (Math.random() - 0.5) * 60;
        let y = (Math.random() - 0.5) * 60;
        let z = (Math.random() - 0.5) * 60;

        // Simple shapes (giữ nguyên ý tưởng)
        if (currentTemplate === 1) { x = 12 * Math.pow(Math.sin(i * 0.1), 3); y = 10 * Math.cos(i * 0.1); }
        // ... thêm shape khác nếu cần

        pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;

        const hue = i / count;
        col[i*3] = hue; col[i*3+1] = 0.9; col[i*3+2] = 0.7;
        size[i] = 1.5 + Math.random() * 2;

        velocities.push(new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02));
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(col, 3).setUsage(THREE.DynamicDrawUsage));
      geometry.setAttribute('size', new THREE.BufferAttribute(size, 1));

      material = new THREE.PointsMaterial({
        vertexColors: true,
        size: 1.2,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }
    createParticles();

    function animate() {
      requestAnimationFrame(animate);

      if (particles) {
        particles.rotation.y += 0.001;

        const positions = geometry.attributes.position.array;
        for (let i = 0; i < count; i++) {
          positions[i*3] += velocities[i].x;
          positions[i*3+1] += velocities[i].y;
          positions[i*3+2] += velocities[i].z;

          const dx = targetPos.x - positions[i*3];
          velocities[i].x += dx * 0.00005;
          // y,z tương tự nếu cần
        }
        geometry.attributes.position.needsUpdate = true;
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ==================== MediaPipe HandLandmarker (new API) ====================
    let handLandmarker;
    let running = false;

    async function createHandLandmarker() {
      const fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
      handLandmarker = await HandLandmarker.createFromOptions(fileset, {
        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task` },
        runningMode: "VIDEO",
        numHands: 1,
        minHandDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      console.log("HandLandmarker ready!");
    }

    const video = document.getElementById('video');

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          running = true;
          predictWebcam();
        };
      } catch (err) {
        console.error("Camera error:", err);
        alert("Không mở camera được. Kiểm tra: HTTPS? Cho phép camera trong Settings > Safari?");
      }
    }

    let lastVideoTime = -1;
    async function predictWebcam() {
      if (running && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const results = await handLandmarker.detectForVideo(video, performance.now());

        if (results.landmarks && results.landmarks.length > 0) {
          const landmarks = results.landmarks[0];

          // Landmarks: 0=wrist, 4=thumb tip, 8=index tip, 12=middle, 16=ring, 20=pinky
          const wrist = landmarks[0];
          const thumb = landmarks[4];
          const index = landmarks[8];
          const middle = landmarks[12];

          // Cử chỉ đơn giản (dễ detect hơn)
          const isOpen = index.y < wrist.y && middle.y < wrist.y && Math.abs(thumb.x - index.x) > 0.05;
          const isFist = thumb.y > index.y && index.y > middle.y;
          const isIndexUp = index.y < thumb.y && index.y < middle.y && index.y < landmarks[16].y;
          const isThumbUp = thumb.y < wrist.y && index.y > thumb.y;

          const tiltX = (wrist.x - 0.5) * 150;
          const tiltY = (wrist.y - 0.5) * -150;

          if (isOpen) {
            material.size = THREE.MathUtils.lerp(material.size, 3.0, 0.1);
          } else if (isFist) {
            material.size = THREE.MathUtils.lerp(material.size, 0.5, 0.15);
            const colors = geometry.attributes.color.array;
            for (let i = 0; i < colors.length; i += 3) {
              colors[i] = Math.random();
              colors[i+1] = 0.8 + Math.random()*0.2;
            }
            geometry.attributes.color.needsUpdate = true;
          } else if (isIndexUp) {
            currentTemplate = (currentTemplate + 1) % templates.length;
            createParticles();
          } else if (isThumbUp) {
            currentTemplate = 4;
            createParticles();
            velocities.forEach(v => v.multiplyScalar(1.8));
          }

          targetPos.set(tiltX, tiltY, 0);
        }
      }
      if (running) requestAnimationFrame(predictWebcam);
    }

    // Init
    createHandLandmarker().then(() => {
      startCamera();
    }).catch(err => {
      console.error("Init error:", err);
      alert("Lỗi khởi tạo MediaPipe. Kiểm tra kết nối hoặc thử browser khác.");
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>3D Gesture Control</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #video-container { position: absolute; bottom: 10px; right: 10px; width: 150px; border-radius: 10px; overflow: hidden; border: 2px solid white; z-index: 10; }
        #input-video { width: 100%; transform: scaleX(-1); }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, particles;
        const videoElement = document.getElementById('input-video');

        // 1. Khởi tạo Three.js (Hệ thống hạt)
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 5000; i++) {
                vertices.push(THREE.MathUtils.randFloatSpread(2000), THREE.MathUtils.randFloatSpread(2000), THREE.MathUtils.randFloatSpread(2000));
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 5 });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            camera.position.z = 500;
        }

        // 2. Nhận diện cử chỉ từ MediaPipe
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Logic nhận diện cử chỉ cơ bản:
                // Nếu khoảng cách giữa ngón cái và ngón trỏ nhỏ -> Pinch (Thu nhỏ/Gom hạt)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const dist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                if (dist < 0.05) {
                    particles.scale.set(0.5, 0.5, 0.5); // Hiệu ứng co lại
                    particles.material.color.setHex(0xff0000);
                } else {
                    particles.scale.set(1, 1, 1);
                    particles.material.color.setHex(0x00ffff);
                }
                
                // Di chuyển hệ thống hạt theo tay
                particles.rotation.y = thumbTip.x * Math.PI;
                particles.rotation.x = thumbTip.y * Math.PI;
            }
        });

        // 3. Khởi chạy Camera
        async function startCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
            videoElement.srcObject = stream;
            videoElement.play();

            async function detectionLoop() {
                await hands.send({ image: videoElement });
                requestAnimationFrame(detectionLoop);
            }
            detectionLoop();
        }

        function animate() {
            requestAnimationFrame(animate);
            particles.rotation.z += 0.001;
            renderer.render(scene, camera);
        }

        initThree();
        startCamera();
        animate();
    </script>
</body>
</html>


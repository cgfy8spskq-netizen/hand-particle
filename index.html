<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Particle System - Advanced Hand Gesture Control (Three.js + MediaPipe)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
    #video { position: absolute; top: 10px; left: 10px; width: 240px; height: 180px; border: 2px solid #0f0; z-index: 10; opacity: 0.7; }
    #info { position: absolute; top: 10px; right: 10px; color: white; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; z-index: 10; }
    canvas { display: block; }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <div id="info">Đưa tay vào khung hình • Mở tay: mở rộng + lung linh • Nắm tay: thu nhỏ + đổi màu ngẫu nhiên • Chỉ ngón trỏ: đổi kiểu particle • Giơ 2 ngón: xoay nhanh • Giơ ngón cái: bùng nổ fireworks • Tay nghiêng: di chuyển particle theo tay</div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <!-- Post-processing for glow/bloom effects -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/shaders/CopyShader.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>

  <script>
    // ==================== Three.js Setup ====================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1f);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 100);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Post-processing for beautiful effects (bloom/glow)
    const composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 1.2;
    bloomPass.radius = 0.6;
    composer.addPass(bloomPass);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const pointLight = new THREE.PointLight(0xffffff, 1.5);
    pointLight.position.set(10, 20, 30);
    scene.add(pointLight);

    // ==================== Particle System ====================
    let particles, particleGeometry, particleMaterial;
    const particleCount = 12000; // Tăng số hạt cho hiệu ứng dày đặc hơn
    let currentTemplate = 0; // 0: default, 1: hearts, 2: flowers, 3: saturn, 4: fireworks
    const templates = ['default', 'hearts', 'flowers', 'saturn', 'fireworks'];
    let velocities = []; // Để thêm animation di chuyển
    let particleTargetPosition = new THREE.Vector3(0, 0, 0); // Để di chuyển theo tay

    function createParticles() {
      if (particles) scene.remove(particles);

      particleGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      velocities = []; // Reset velocities

      for (let i = 0; i < particleCount; i++) {
        let x = (Math.random() - 0.5) * 80;
        let y = (Math.random() - 0.5) * 80;
        let z = (Math.random() - 0.5) * 80;

        // Shape variations with more details
        if (currentTemplate === 1) { // hearts
          const angle = Math.random() * Math.PI * 2;
          const r = 0.4 + Math.random() * 0.6;
          x = 16 * Math.pow(Math.sin(angle), 3);
          y = 13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle);
          z = (Math.random() - 0.5) * 10;
        } else if (currentTemplate === 2) { // flowers
          const petals = 5 + Math.floor(Math.random() * 3); // 5-7 petals
          const angle = Math.random() * Math.PI * 2;
          const dist = 20 * (0.5 + Math.random());
          x = dist * Math.cos(angle) * Math.sin(petals * angle);
          y = dist * Math.sin(angle) * Math.sin(petals * angle);
          z = (Math.random() - 0.5) * 12;
        } else if (currentTemplate === 3) { // saturn with rings
          if (Math.random() > 0.3) { // Planet core
            x = (Math.random() - 0.5) * 20;
            y = (Math.random() - 0.5) * 20;
            z = (Math.random() - 0.5) * 20;
          } else { // Rings
            const angle = Math.random() * Math.PI * 2;
            const ringDist = 25 + Math.random() * 15;
            x = Math.cos(angle) * ringDist;
            y = Math.sin(angle) * ringDist * 0.1; // Tilted ring
            z = 0;
          }
        } else if (currentTemplate === 4) { // fireworks with trails
          const radius = Math.random() * 40;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          x = radius * Math.sin(phi) * Math.cos(theta);
          y = radius * Math.sin(phi) * Math.sin(theta);
          z = radius * Math.cos(phi);
        }

        positions[i * 3]     = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        // Multi-color: rainbow spectrum
        const hue = i / particleCount;
        colors[i * 3]     = hue;
        colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
        colors[i * 3 + 2] = 0.6 + Math.random() * 0.4;
        sizes[i] = 1.5 + Math.random() * 3;

        // Velocity for movement
        velocities.push(new THREE.Vector3((Math.random() - 0.5) * 0.05, (Math.random() - 0.5) * 0.05, (Math.random() - 0.5) * 0.05));
      }

      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage)); // Dynamic for color changes
      particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      particleMaterial = new THREE.PointsMaterial({
        vertexColors: true,
        size: 1.0,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        map: createSparkleTexture() // Add sparkle texture for lung linh
      });

      particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);
    }

    // Create a sparkle texture for lung linh effect
    function createSparkleTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.1, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 64, 64);
      return new THREE.CanvasTexture(canvas);
    }

    createParticles();

    // Animation loop with effects
    let rotationSpeed = 0.001;
    function animate() {
      requestAnimationFrame(animate);

      if (particles) {
        particles.rotation.y += rotationSpeed;
        particles.rotation.x += rotationSpeed * 0.5;

        // Animate particles: movement + attract to target
        const positions = particleGeometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] += velocities[i].x;
          positions[i * 3 + 1] += velocities[i].y;
          positions[i * 3 + 2] += velocities[i].z;

          // Attract to target position (from hand tilt)
          const dx = particleTargetPosition.x - positions[i * 3];
          const dy = particleTargetPosition.y - positions[i * 3 + 1];
          const dz = particleTargetPosition.z - positions[i * 3 + 2];
          velocities[i].x += dx * 0.0001;
          velocities[i].y += dy * 0.0001;
          velocities[i].z += dz * 0.0001;

          // Bound particles
          if (Math.abs(positions[i * 3]) > 100) velocities[i].x *= -0.8;
          if (Math.abs(positions[i * 3 + 1]) > 100) velocities[i].y *= -0.8;
          if (Math.abs(positions[i * 3 + 2]) > 100) velocities[i].z *= -0.8;
        }
        particleGeometry.attributes.position.needsUpdate = true;
      }

      composer.render(); // Use composer for bloom effect
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // ==================== MediaPipe Hands Setup ====================
    const videoElement = document.getElementById('video');
    const hands = new Hands({locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
    }});

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraFeed = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({image: videoElement});
      },
      width: 480,
      height: 360
    });
    cameraFeed.start();

    let lastGestureTime = 0; // To debounce gesture changes
    function onResults(results) {
      if (results.multiHandLandmarks && results.multiHandedness) {
        const hand = results.multiHandLandmarks[0];
        const now = Date.now();
        if (now - lastGestureTime < 500) return; // Debounce 0.5s

        // Landmarks
        const wrist = hand[0];
        const thumbTip = hand[4];
        const indexTip = hand[8];
        const middleTip = hand[12];
        const ringTip = hand[16];
        const pinkyTip = hand[20];

        // More gestures
        const isOpenPalm = 
          thumbTip.y < wrist.y && 
          indexTip.y < wrist.y && 
          middleTip.y < wrist.y && 
          ringTip.y < wrist.y && 
          pinkyTip.y < wrist.y &&
          Math.abs(thumbTip.x - pinkyTip.x) > 0.1; // Tay mở rộng

        const isFist = 
          thumbTip.y > indexTip.y && 
          indexTip.y > middleTip.y && 
          middleTip.y > ringTip.y && 
          ringTip.y > pinkyTip.y; // Nắm tay

        const isIndexUp = 
          indexTip.y < thumbTip.y && 
          indexTip.y < middleTip.y && 
          indexTip.y < ringTip.y && 
          indexTip.y < pinkyTip.y; // Chỉ ngón trỏ

        const isTwoFingers = 
          indexTip.y < wrist.y && 
          middleTip.y < wrist.y && 
          ringTip.y > middleTip.y && 
          pinkyTip.y > middleTip.y && 
          thumbTip.y > indexTip.y; // Giơ 2 ngón (V-sign-ish)

        const isThumbUp = 
          thumbTip.y < wrist.y && 
          indexTip.y > thumbTip.y && 
          middleTip.y > thumbTip.y && 
          ringTip.y > thumbTip.y && 
          pinkyTip.y > thumbTip.y; // Giơ ngón cái

        const handTiltX = (wrist.x - 0.5) * 200; // Nghiêng tay để di chuyển
        const handTiltY = (wrist.y - 0.5) * -200;

        // Controls
        if (isOpenPalm) {
          // Mở rộng + tăng bloom cho lung linh
          particleMaterial.size = THREE.MathUtils.lerp(particleMaterial.size, 3.5, 0.1);
          bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 2.0, 0.1);
        } else if (isFist) {
          // Thu nhỏ + random multi-color
          particleMaterial.size = THREE.MathUtils.lerp(particleMaterial.size, 0.5, 0.15);
          const colors = particleGeometry.attributes.color.array;
          for (let i = 0; i < particleCount; i++) {
            colors[i * 3] = Math.random();
            colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
            colors[i * 3 + 2] = 0.5 + Math.random() * 0.5;
          }
          particleGeometry.attributes.color.needsUpdate = true;
        } else if (isIndexUp) {
          // Đổi template
          currentTemplate = (currentTemplate + 1) % templates.length;
          createParticles();
        } else if (isTwoFingers) {
          // Xoay nhanh
          rotationSpeed = THREE.MathUtils.lerp(rotationSpeed, 0.02, 0.1);
        } else if (isThumbUp) {
          // Bùng nổ fireworks: reset to fireworks and explode
          currentTemplate = 4;
          createParticles();
          for (let i = 0; i < velocities.length; i++) {
            velocities[i].multiplyScalar(1.5); // Burst speed
          }
        }

        // Di chuyển particle theo nghiêng tay (luôn active nếu có tay)
        particleTargetPosition.set(handTiltX, handTiltY, 0);

        lastGestureTime = now;
      } else {
        // No hand: gradually reset
        rotationSpeed = THREE.MathUtils.lerp(rotationSpeed, 0.001, 0.05);
        bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 1.2, 0.05);
        particleTargetPosition.set(0, 0, 0);
      }
    }
  </script>
</body>
</html>
